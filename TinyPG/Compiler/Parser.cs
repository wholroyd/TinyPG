// Generated by TinyPG v1.3 available at www.codeproject.com

namespace TinyPG.Compiler
{
    public class Parser 
    {
        private readonly Scanner _scanner;

        private ParseTree _tree;
        
        public Parser(Scanner scanner)
        {
            this._scanner = scanner;
        }

        public ParseTree Parse(string input, string fileName)
        {
            this._tree = new ParseTree();
            return this.Parse(input, fileName, this._tree);
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            this._scanner.Init(input, fileName);

            this._tree = tree;
            this.ParseStart(tree);
            tree.Skipped = this._scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            var tok = this._scanner.LookAhead(TokenType.DIRECTIVEOPEN);
            while (tok.Type == TokenType.DIRECTIVEOPEN)
            {
                this.ParseDirective(node);
            tok = this._scanner.LookAhead(TokenType.DIRECTIVEOPEN);
            }

            
            tok = this._scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER);
            while (tok.Type == TokenType.SQUAREOPEN
                || tok.Type == TokenType.IDENTIFIER)
            {
                this.ParseExtProduction(node);
            tok = this._scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER);
            }

            
            tok = this._scanner.Scan(TokenType.EOF);
            var n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF, 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseDirective(ParseNode parent)
        {
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Directive), "Directive");
            parent.Nodes.Add(node);


            
            var tok = this._scanner.Scan(TokenType.DIRECTIVEOPEN);
            var n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DIRECTIVEOPEN) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVEOPEN, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.LookAhead(TokenType.IDENTIFIER);
            while (tok.Type == TokenType.IDENTIFIER)
            {
                this.ParseNameValue(node);
            tok = this._scanner.LookAhead(TokenType.IDENTIFIER);
            }

            
            tok = this._scanner.Scan(TokenType.DIRECTIVECLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DIRECTIVECLOSE) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVECLOSE, 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseNameValue(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.NameValue), "NameValue");
            parent.Nodes.Add(node);


            
            tok = this._scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.Scan(TokenType.ASSIGN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGN) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.Scan(TokenType.STRING);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExtProduction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.ExtProduction), "ExtProduction");
            parent.Nodes.Add(node);


            
            tok = this._scanner.LookAhead(TokenType.SQUAREOPEN);
            while (tok.Type == TokenType.SQUAREOPEN)
            {
                this.ParseAttribute(node);
            tok = this._scanner.LookAhead(TokenType.SQUAREOPEN);
            }

            
            this.ParseProduction(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAttribute(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Attribute), "Attribute");
            parent.Nodes.Add(node);


            
            tok = this._scanner.Scan(TokenType.SQUAREOPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUAREOPEN) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.LookAhead(TokenType.BRACKETOPEN);
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                
                tok = this._scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN, 0x1001, tok));
                    return;
                }

                
                tok = this._scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX);
                if (tok.Type == TokenType.INTEGER
                    || tok.Type == TokenType.DOUBLE
                    || tok.Type == TokenType.STRING
                    || tok.Type == TokenType.HEX)
                {
                    this.ParseParams(node);
                }

                
                tok = this._scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE, 0x1001, tok));
                    return;
                }
            }

            
            tok = this._scanner.Scan(TokenType.SQUARECLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUARECLOSE) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE, 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParams(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Params), "Params");
            parent.Nodes.Add(node);


            
            this.ParseParam(node);

            
            tok = this._scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = this._scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA, 0x1001, tok));
                    return;
                }

                
                this.ParseParam(node);
            tok = this._scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParam(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Param), "Param");
            parent.Nodes.Add(node);

            tok = this._scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                    tok = this._scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = this._scanner.Scan(TokenType.DOUBLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = this._scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.HEX:
                    tok = this._scanner.Scan(TokenType.HEX);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.HEX) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX, 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseProduction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Production), "Production");
            parent.Nodes.Add(node);


            
            tok = this._scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
                return;
            }

            
            tok = this._scanner.Scan(TokenType.ARROW);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ARROW) {
                this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW, 0x1001, tok));
                return;
            }

            
            this.ParseRule(node);

            
            tok = this._scanner.LookAhead(TokenType.CODEBLOCK, TokenType.SEMICOLON);
            switch (tok.Type)
            {
                case TokenType.CODEBLOCK:
                    tok = this._scanner.Scan(TokenType.CODEBLOCK);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CODEBLOCK) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CODEBLOCK, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.SEMICOLON:
                    tok = this._scanner.Scan(TokenType.SEMICOLON);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SEMICOLON) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON, 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRule(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Rule), "Rule");
            parent.Nodes.Add(node);

            tok = this._scanner.LookAhead(TokenType.STRING, TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
            switch (tok.Type)
            {
                case TokenType.STRING:
                    tok = this._scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                case TokenType.BRACKETOPEN:
                    this.ParseSubrule(node);
                    break;
                default:
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSubrule(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Subrule), "Subrule");
            parent.Nodes.Add(node);


            
            this.ParseConcatRule(node);

            
            tok = this._scanner.LookAhead(TokenType.PIPE);
            while (tok.Type == TokenType.PIPE)
            {

                
                tok = this._scanner.Scan(TokenType.PIPE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PIPE) {
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PIPE, 0x1001, tok));
                    return;
                }

                
                this.ParseConcatRule(node);
            tok = this._scanner.LookAhead(TokenType.PIPE);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConcatRule(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.ConcatRule), "ConcatRule");
            parent.Nodes.Add(node);

            do {
                this.ParseSymbol(node);
                tok = this._scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
            } while (tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BRACKETOPEN);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSymbol(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(this._scanner.GetToken(TokenType.Symbol), "Symbol");
            parent.Nodes.Add(node);


            
            tok = this._scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
            switch (tok.Type)
            {
                case TokenType.IDENTIFIER:
                    tok = this._scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.BRACKETOPEN:

                    
                    tok = this._scanner.Scan(TokenType.BRACKETOPEN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN, 0x1001, tok));
                        return;
                    }

                    
                    this.ParseSubrule(node);

                    
                    tok = this._scanner.Scan(TokenType.BRACKETCLOSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE, 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            tok = this._scanner.LookAhead(TokenType.UNARYOPER);
            if (tok.Type == TokenType.UNARYOPER)
            {
                tok = this._scanner.Scan(TokenType.UNARYOPER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNARYOPER) {
                    this._tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYOPER, 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }


    }
}
